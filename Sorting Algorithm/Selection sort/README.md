
```
A = [9, 13, 15, 11, 2],  n = 5
```

---

# Selection Sort — ধারণা

* প্রতি **ইটারেশনে (i-th pass)**, বাম দিকের `i`-এর পরের অংশটাকে **unsorted** ধরা হয়।
* ওই unsorted অংশ থেকে **সর্বনিম্ন (minimum) মান** খুঁজে, সেটিকে **index i**-তে এনে **swap** করা হয়।
* ফলে `0..i` অংশ **sorted**, আর `i+1..n-1` অংশ **unsorted** থাকে।
* মোট `i = 0..n-2` (মানে `n-1` বার) এই প্রক্রিয়া চলে।

---

# ট্রেস 

প্রতি ধাপে:

* `i` = বর্তমান পাসের শুরুর পজিশন (sorted অংশের শেষ + 1)
* `min` = এখন পর্যন্ত পাওয়া সবচেয়ে ছোট এলিমেন্টের **index**
* শেষে `A[i]` ↔ `A[min]` **swap** (যদি `min != i`)

### শুরু:

```
Index: 0  1   2   3   4
A    : 9 13  15  11   2
       ^----------------  (sorted | unsorted)
```

### it-1 (i = 0)

Unsorted অংশ: index 0..4

```
min = 0  → A[min] = 9
j = 1: A[1]=13  < A[min]=9  ?  না  → min অপরিবর্তিত
j = 2: A[2]=15  < 9 ?  না
j = 3: A[3]=11  < 9 ?  না
j = 4: A[4]= 2  < 9 ?  হ্যাঁ → min = 4
swap A[0] ↔ A[4]
A = [2, 13, 15, 11, 9]
```

এখন `0` তম ঘর ঠিক হয়েছে → `0..0` **sorted**, `1..4` **unsorted**

### it-2 (i = 1)

Unsorted অংশ: index 1..4

```
min = 1  → A[min] = 13
j = 2: A[2]=15 < 13 ? না
j = 3: A[3]=11 < 13 ? হ্যাঁ → min = 3
j = 4: A[4]= 9 < 11 ? হ্যাঁ → min = 4
swap A[1] ↔ A[4]
A = [2, 9, 15, 11, 13]
```

এখন `0..1` **sorted**, `2..4` **unsorted**

### it-3 (i = 2)

Unsorted অংশ: index 2..4

```
min = 2  → A[min] = 15
j = 3: A[3]=11 < 15 ? হ্যাঁ → min = 3
j = 4: A[4]=13 < 11 ? না
swap A[2] ↔ A[3]
A = [2, 9, 11, 15, 13]
```

`0..2` **sorted**, `3..4` **unsorted**

### it-4 (i = 3)

Unsorted অংশ: index 3..4

```
min = 3  → A[min] = 15
j = 4: A[4]=13 < 15 ? হ্যাঁ → min = 4
swap A[3] ↔ A[4]
A = [2, 9, 11, 13, 15]
```

সব শেষ—অ্যারে **sorted** ✅


---

# C++ কোড 

```cpp
void selection_sort(int A[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int min = i;
        for (int j = i + 1; j < n; ++j) {
            if (A[j] < A[min]) min = j;
        }
        if (min != i) {
            int temp = A[i];
            A[i] = A[min];
            A[min] = temp;
        }
    }
}
```

---

# Time Complexity 

ইনার লুপে তুলনার সংখ্যা:

```
(n-1) + (n-2) + ... + 2 + 1
= n(n-1)/2
= Θ(n^2)
```

* **Best / Average / Worst** — সবক্ষেত্রেই তুলনা `Θ(n^2)`
* **Swaps** সর্বোচ্চ `n-1` বার → `Θ(n)`
* মোট সময়: **Θ(n²)**

# Space Complexity

* অতিরিক্ত জায়গা প্রায় নেই (এক-দুইটা টেম্প ভ্যারিয়েবল) → **Θ(1)**
* ইন-প্লেস, কিন্তু **স্টেবল নয়** (সমান মানের আপেক্ষিক অর্ডার নাও বজায় থাকতে পারে)।

---

